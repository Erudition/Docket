module Task.Instance exposing (..)

import Incubator.IntDict.Extra as IntDict
import IntDict exposing (IntDict)
import Json.Decode.Exploration as Decode exposing (..)
import Json.Decode.Exploration.Pipeline as Pipeline exposing (..)
import Json.Encode as Encode exposing (..)
import Json.Encode.Extra as Encode2 exposing (..)
import SmartTime.Duration exposing (Duration)
import SmartTime.Human.Clock as Clock
import SmartTime.Human.Moment as HumanMoment exposing (FuzzyMoment)
import SmartTime.Moment exposing (..)
import SmartTime.Period exposing (Period)
import Task.Class exposing (Class, ClassID, ClassSkel, ParentProperties, decodeClassID, decodeTaskMoment, encodeTaskMoment)
import Task.Entry exposing (Entry, buildFullClassDict)
import Task.Progress as Progress exposing (..)
import Task.SessionSkel exposing (UserPlannedSession, decodeSession, encodeSession)



-- Instance Skeleton (bare minimum, non-derivative data, saved to disk) --------------------------------


{-| Definition of a single task.
Working rules:

  - there should be no fields for storing data that can be fully derived from other fields [consistency]
  - combine related fields into a single one with a tuple value [minimalism]

-- One particular time that the specific thing will be done, that can be scheduled
-- A class could have NO instances yet - they're calculated on the fly

-}
type alias InstanceSkel =
    { class : ClassID
    , id : InstanceID
    , completion : Progress.Portion
    , externalDeadline : Maybe FuzzyMoment -- *
    , startBy : Maybe FuzzyMoment -- *
    , finishBy : Maybe FuzzyMoment -- *
    , plannedSessions : List UserPlannedSession
    , relevanceStarts : Maybe FuzzyMoment -- *
    , relevanceEnds : Maybe FuzzyMoment -- * (*)=An absolute FuzzyMoment if specified, otherwise generated by relative rules from class
    }


decodeInstance : Decode.Decoder InstanceSkel
decodeInstance =
    decode InstanceSkel
        |> Pipeline.required "class" decodeClassID
        |> Pipeline.required "id" decodeInstanceID
        |> Pipeline.required "completion" Decode.int
        |> Pipeline.required "externalDeadline" (Decode.nullable decodeTaskMoment)
        |> Pipeline.required "startBy" (Decode.nullable decodeTaskMoment)
        |> Pipeline.required "finishBy" (Decode.nullable decodeTaskMoment)
        |> Pipeline.required "plannedSessions" (Decode.list decodeSession)
        |> Pipeline.required "relevanceStarts" (Decode.nullable decodeTaskMoment)
        |> Pipeline.required "relevanceEnds" (Decode.nullable decodeTaskMoment)


encodeInstance : InstanceSkel -> Encode.Value
encodeInstance taskInstance =
    Encode.object <|
        [ ( "class", Encode.int taskInstance.class )
        , ( "id", Encode.int taskInstance.id )
        , ( "completion", Encode.int taskInstance.completion )
        , ( "externalDeadline", Encode2.maybe encodeTaskMoment taskInstance.externalDeadline )
        , ( "startBy", Encode2.maybe encodeTaskMoment taskInstance.startBy )
        , ( "finishBy", Encode2.maybe encodeTaskMoment taskInstance.finishBy )
        , ( "plannedSessions", Encode.list encodeSession taskInstance.plannedSessions )
        , ( "relevanceStarts", Encode2.maybe encodeTaskMoment taskInstance.relevanceStarts )
        , ( "relevanceEnds", Encode2.maybe encodeTaskMoment taskInstance.relevanceEnds )
        ]


newInstanceSkel : Int -> ClassSkel -> InstanceSkel
newInstanceSkel newID class =
    { class = class.id
    , id = newID
    , completion = 0
    , externalDeadline = Nothing
    , startBy = Nothing
    , finishBy = Nothing
    , plannedSessions = []
    , relevanceStarts = Nothing
    , relevanceEnds = Nothing
    }


type alias InstanceID =
    Int


decodeInstanceID : Decoder InstanceID
decodeInstanceID =
    Decode.int


encodeInstanceID : InstanceID -> Encode.Value
encodeInstanceID taskInstanceID =
    Encode.int taskInstanceID



-- FULL Instances (augmented with Entry & Class) ----------------------------------------


{-| A fully spec'ed-out version of a TaskInstance
-}
type alias Instance =
    { parents : List ParentProperties
    , class : ClassSkel
    , instance : InstanceSkel
    }


{-| Take the skeleton data and get all relevant(within given time period) instances of every class, and return them as Full Instances.
-}
buildRelevantInstanceDict : ( List Entry, IntDict.IntDict ClassSkel, IntDict.IntDict InstanceSkel ) -> Maybe Period -> IntDict.IntDict Instance
buildRelevantInstanceDict ( entries, classes, instances ) relevantPeriod =
    let
        fullClasses =
            buildFullClassDict ( entries, classes )

        findClass taskClassID =
            IntDict.get taskClassID fullClasses

        fleshOutInstanceIfClassFound taskInstance =
            case findClass taskInstance.class of
                Nothing ->
                    Debug.log
                        ("Couldn't find a matching class (ID "
                            ++ String.fromInt taskInstance.class
                            ++ ") for instance ID "
                            ++ String.fromInt taskInstance.id
                        )
                        Nothing

                Just foundClass ->
                    Just <| buildRelevantInstancesFromClass relevantPeriod foundClass instances
    in
    IntDict.filterMapValues fleshOutInstanceIfClassFound instances


{-| Take a class and return all of the instances relevant within the given period - saved or generated.

Combine the saved instances with generated ones, to get the full picture within a period.

TODO: best data structure? Is Dict unnecessary here? Or should the key involve the classID for perf?

-}
buildRelevantInstancesFromClass : Maybe Period -> Class -> IntDict InstanceSkel -> List Instance
buildRelevantInstancesFromClass relevantPeriod class allSavedInstances =
    let
        -- Any & all saved instances that match this taskclass
        savedInstancesWithMatchingClass =
            IntDict.filterValues (\instance -> instance.class == class.class.id) allSavedInstances

        savedInstancesFull =
            IntDict.mapValues toFull savedInstancesWithMatchingClass

        toFull instanceSkel =
            { parents = class.parents
            , class = class
            , instance = instanceSkel
            }

        -- Filter out instances outside the window
        relevantSavedInstances =
            IntDict.filterValues isRelevant savedInstancesFull

        -- TODO "If savedInstance is within period, keep"
        isRelevant savedInstance =
            True

        -- TODO Fill in based on recurrence series. Int ID = order in series.
        generatedInstances =
            IntDict.empty

        -- TODO Use series order ID to filter only relevant instances
        relevantSeriesMembers =
            IntDict.filterKeys isRelevant generatedInstances
    in
    relevantSavedInstances
        ++ generatedInstances


instanceProgress : Instance -> Progress
instanceProgress fullInstance =
    ( fullInstance.instance.completion, fullInstance.class.completionUnits )



-- Task helper functions ---------------------------------------------


completed : Instance -> Bool
completed spec =
    isMax ( spec.instance.completion, spec.class.completionUnits )


type alias WithSoonness t =
    { t | soonness : Duration }


prioritize : Moment -> HumanMoment.Zone -> List Instance -> List Instance
prioritize now zone taskList =
    let
        -- lowest values first
        compareProp prop a b =
            Basics.compare (prop a) (prop b)

        -- highest values first
        comparePropInverted prop a b =
            Basics.compare (prop b) (prop a)
    in
    -- deepSort [ compareSoonness zone, comparePropInverted .importance ] taskList
    deepSort [ compareSoonness zone ] taskList



-- List.sortWith (compareSoonness zone) <| List.sortBy .importance taskList


type alias CompareFunction a =
    a -> a -> Basics.Order


deepSort : List (CompareFunction a) -> List a -> List a
deepSort compareFuncs listToSort =
    let
        deepCompare funcs a b =
            case funcs of
                [] ->
                    -- No more comparisons to make, give up and say they're equal
                    EQ

                nextCompareFunc :: laterCompareFuncs ->
                    let
                        -- run next comparison
                        check =
                            nextCompareFunc a b
                    in
                    if check == EQ then
                        -- they still look equal, dig deeper
                        deepCompare laterCompareFuncs a b

                    else
                        -- we have a winner, we can stop digging
                        check
    in
    List.sortWith (deepCompare compareFuncs) listToSort


{-| TODO this could be a Moment.Fuzzy function
-}
compareSoonness : HumanMoment.Zone -> CompareFunction Instance
compareSoonness zone taskA taskB =
    case ( taskA.instance.externalDeadline, taskB.instance.externalDeadline ) of
        ( Just fuzzyMomentA, Just fuzzyMomentB ) ->
            HumanMoment.compareFuzzyLateness zone Clock.endOfDay fuzzyMomentA fuzzyMomentB

        ( Nothing, Nothing ) ->
            -- whenevers can't be compared
            EQ

        ( Just _, Nothing ) ->
            -- actual times always come before whenevers
            LT

        ( Nothing, Just _ ) ->
            -- whenevers always come after actual times
            GT
